# -*- coding: utf-8 -*-
"""Multi-Output Classification Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XR_M310bBNxIWfgaCZtmqIQFLLdqB0ON

**Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense
from keras.layers import Dropout
from tensorflow.keras.utils import to_categorical

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.metrics import accuracy_score

"""# **Data Wrangling**

**Gathering Data**
"""

gymdiet_df = pd.read_csv('https://raw.githubusercontent.com/gitagpds/dataset_fix/refs/heads/main/gym_and_diet_recommendation_cleaned_data.csv')

gymdiet_df.head()

"""Menampilkan 5 baris pertama dari DataFrame gymdiet

**Assessing Data**
"""

gymdiet_df.shape

gymdiet_df.info()

"""Tidak ada masalah dengan tipe data dan jumlah data dari seluruh kolom tersebut"""

gymdiet_df.isnull().sum()

"""Tidak terdapat missing values"""

print("Jumlah duplikasi: ", gymdiet_df.duplicated().sum())

"""Tidak ada data yang duplikat"""

gymdiet_df.describe()

"""Tidak ada inaccurate value pada kolom ID, Age, Height, Weight

# **Exploratory Data Analysis (EDA)**
"""

gymdiet_df.sample(5)

gymdiet_df.describe(include="all")

gymdiet_df.groupby(by="Age").ID.nunique().sort_values(ascending=False)

gymdiet_df.groupby(by="Height").ID.nunique().sort_values(ascending=False)

gymdiet_df.groupby(by="Weight").ID.nunique().sort_values(ascending=False)

fig, axes = plt.subplots(2, 2, figsize=(15, 10))

sns.boxplot(ax=axes[0,0],x= gymdiet_df['Age'], palette = "Set1")
axes[0,0].set_title('Age Of People')

# Pass gymdiet_df to the data parameter
sns.boxplot(ax=axes[0,1],x='Age', data=gymdiet_df, color="g")
axes[0,1].set_title('Distribution Of Ages')

# Pass gymdiet_df['Height'] to the x parameter, or gymdiet_df to the data parameter and 'Height' to x
sns.boxplot(ax=axes[1,0],x=gymdiet_df['Height'])
axes[1,0].set_title('Distribution Of Height')

# Pass gymdiet_df to the data parameter
sns.boxplot(ax=axes[1,1],x='Weight',data=gymdiet_df,color="y")
axes[1,1].set_title('Distribution of Weight')

plt.show()

"""# **Preprocessing Data**"""

# Encode categorical data
categorical_columns = ['Sex', 'Hypertension', 'Diabetes', 'Exercises', 'Diet']
label_encoders = {}

for col in categorical_columns:
    le = LabelEncoder()
    gymdiet_df[col] = le.fit_transform(gymdiet_df[col])
    label_encoders[col] = le

# Normalize numerical data
numerical_columns = ['Age', 'Height', 'Weight']
scaler = StandardScaler()
gymdiet_df[numerical_columns] = scaler.fit_transform(gymdiet_df[numerical_columns])

# Separate features and targets
X = gymdiet_df[['Sex', 'Age', 'Height', 'Weight', 'Hypertension', 'Diabetes']]
y_exercises = gymdiet_df['Exercises']
y_diet = gymdiet_df['Diet']

# Train-test split

# Split for exercises and diet target
X_train, X_test, y_train, y_test = train_test_split(
    X,
    np.column_stack((y_exercises, y_diet)),
    test_size=0.2,
    random_state=42
)

# Encode the 'Diet' column with LabelEncoder first
diet_encoder = LabelEncoder()
y_train_diet_labels = diet_encoder.fit_transform(y_train[:, 1])
y_test_diet_labels = diet_encoder.transform(y_test[:, 1])

# Now apply one-hot encoding
y_train_diet = to_categorical(y_train_diet_labels, num_classes=10)
y_test_diet = to_categorical(y_test_diet_labels, num_classes=10)

# For exercises, continue with one-hot encoding
y_train_exercises = to_categorical(y_train[:, 0], num_classes=5)
y_test_exercises = to_categorical(y_test[:, 0], num_classes=5)

# Check for NaN or missing values in your target variables
print("NaN in y_train_exercises:", np.isnan(y_train_exercises).any())
print("NaN in y_train_diet:", np.isnan(y_train_diet).any())
print("NaN in y_test_exercises:", np.isnan(y_test_exercises).any())
print("NaN in y_test_diet:", np.isnan(y_test_diet).any())

# Check and print the shapes again for confirmation
print("X_train shape:", X_train.shape)
print("y_train_exercises shape:", y_train_exercises.shape)
print("y_train_diet shape:", y_train_diet.shape)
print("y_test_exercises shape:", y_test_exercises.shape)
print("y_test_diet shape:", y_test_diet.shape)

# Ensure your target variables are of type 'float32'
y_train_exercises = y_train_exercises.astype('float32')
y_train_diet = y_train_diet.astype('float32')
y_test_exercises = y_test_exercises.astype('float32')
y_test_diet = y_test_diet.astype('float32')

"""# **Build Model**"""

# Define Inputs
input_layer = Input(shape=(X_train.shape[1],))

# Shared Hidden Layers
hidden = Dense(128, activation='relu')(input_layer)
hidden = Dropout(0.3)(hidden)
hidden = Dense(64, activation='relu')(hidden)
hidden = Dropout(0.3)(hidden)
hidden = Dense(32, activation='relu')(hidden)

# Output 1: Exercises (5 classes)
output_exercises = Dense(5, activation='softmax', name='Exercises')(hidden)

# Output 2: Diet (10 classes)
output_diet = Dense(10, activation='softmax', name='Diet')(hidden)

# Create Model
model = Model(inputs=input_layer, outputs=[output_diet, output_exercises])

# Compile Model
model.compile(
    optimizer='adam',
    loss={
        'Exercises': 'categorical_crossentropy',
        'Diet': 'categorical_crossentropy'
    },
    metrics={
        'Exercises': ['accuracy'],
        'Diet': ['accuracy']
    }
)

# Model Summary
model.summary()

"""# **Training Data**"""

# Train Model
history = model.fit(
    X_train,
    {'Exercises': y_train_exercises, 'Diet': y_train_diet},
    validation_data=(X_test, {'Exercises': y_test_exercises, 'Diet': y_test_diet}),
    epochs=50,
    batch_size=32
)

"""# **Evaluate Model**"""

# Evaluate model on test data
evaluation = model.evaluate(
    X_test,
    {'Exercises': y_test_exercises, 'Diet': y_test_diet}
)

print(f"Test Loss (Exercises): {evaluation[2]}")
print(f"Test Accuracy (Exercises): {evaluation[4]}")
print(f"Test Loss (Diet): {evaluation[1]}")
print(f"Test Accuracy (Diet): {evaluation[3]}")

# Plot training & validation loss for Exercises
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(history.history['Exercises_loss'], label='Exercises Train Loss')
plt.plot(history.history['val_Exercises_loss'], label='Exercises Val Loss')
plt.title('Exercises Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

# Plot training & validation accuracy for Exercises
plt.subplot(1, 2, 2)
plt.plot(history.history['Exercises_accuracy'], label='Exercises Train Accuracy')
plt.plot(history.history['val_Exercises_accuracy'], label='Exercises Val Accuracy')
plt.title('Exercises Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Plot training & validation loss for Diet
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(history.history['Diet_loss'], label='Diet Train Loss')
plt.plot(history.history['val_Diet_loss'], label='Diet Val Loss')
plt.title('Diet Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

# Plot training & validation accuracy for Diet
plt.subplot(1, 2, 2)
plt.plot(history.history['Diet_accuracy'], label='Diet Train Accuracy')
plt.plot(history.history['val_Diet_accuracy'], label='Diet Val Accuracy')
plt.title('Diet Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Assume 'model' is the trained model you want to use for prediction.
prediksi = X_test.iloc[:1].copy()  # Assuming you want to predict for the first row of X_test

# Get predictions for both outputs
predictions = model.predict(prediksi)

# Access predictions for diet and exercises separately
# Get the predicted class index (argmax) for diet and exercises
predicted_diet_class = predictions[0].argmax(axis=1)[0]
predicted_exercises_class = predictions[1].argmax(axis=1)[0]

# Create a dictionary with predictions, ensuring consistent lengths
pred_dict = {
    'y_true_exercises': y_test[:1, 0],  # True exercises value for the first row
    'y_true_diet': y_test[:1, 1],  # True diet value for the first row
    'predicted_diet': [predicted_diet_class],  # Predicted diet class as a single-element list
    'predicted_exercises': [predicted_exercises_class]  # Predicted exercises class as a single-element list
}

# Create DataFrame and transpose for better readability
prediction_df = pd.DataFrame(pred_dict).T
prediction_df.columns = ['Values']
prediction_df

"""**Saving Model**"""

# Save the model in .h5 format
model.save('gymdiet_model.h5')

print("Model saved as gymdiet_model.h5")

# Convert the model to TensorFlow Lite
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

# Save the converted model
with open('gymdiet_model.tflite', 'wb') as f:
    f.write(tflite_model)

print("Model saved as gymdiet_model.tflite")